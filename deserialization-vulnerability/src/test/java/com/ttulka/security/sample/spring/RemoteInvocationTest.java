package com.ttulka.security.sample.spring;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

import com.ttulka.security.Exploit;
import com.ttulka.security.sample.Vulnerable;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.io.TempDir;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.web.server.LocalServerPort;
import org.springframework.remoting.support.RemoteInvocation;

import sun.misc.ObjectInputFilter;

import static com.ttulka.security.SerializationUtils.serialize;
import static com.ttulka.security.sample.spring.Application.SERVICE_PATH;
import static io.restassured.RestAssured.given;
import static java.util.concurrent.TimeUnit.SECONDS;
import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;

/**
 * Notice, that this test must be executed as last to make the other suites run,
 * because the Serial Filter can be set only once.
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class RemoteInvocationTest {

    @Test
    @Order(1)
    void remote_invocation_is_hacked(@LocalServerPort int port, @TempDir Path tempDir) throws Exception {
        Path exploitFile = tempDir.resolve("exploit.ser" + RemoteInvocationTest.class.getSimpleName());
        Path hackedFile = tempDir.resolve("_YOU_HAVE_BEEN_HACKED_" + RemoteInvocationTest.class.getSimpleName());

        createExploit(exploitFile, hackedFile);

        given()
            .port(port)
            .contentType("application/x-java-serialized-object")
            .body(Files.newInputStream(exploitFile)).
        when()
            .post(SERVICE_PATH).
        then()
            .statusCode(500);

        await().atMost(2, SECONDS)
                .until(() -> Files.exists(hackedFile));
    }

    /** uses external exploit, not included on the classpath of the application */
    @Test
    @Order(2)
    void external_exploit_is_executed_on_server(@LocalServerPort int port) throws Exception {
        given()
            .port(port)
            .contentType("application/x-java-serialized-object")
            .body(this.getClass().getResourceAsStream("/exploit.ser")). // generated by ExploitExternal.main()
        when()
            .post(SERVICE_PATH).
        then()
            .statusCode(500);

        await().atMost(2, SECONDS)
                .until(() -> Files.exists(Paths.get("_HACKED_")));

        Files.delete(Paths.get("_HACKED_"));
    }

    @Test
    @Order(3)
    void exploit_is_not_executed_when_filter_is_set(@LocalServerPort int port) throws Exception {
        ObjectInputFilter filter = ObjectInputFilter.Config.createFilter(
                "java.lang.Class;java.lang.Object;java.lang.String;" +
                "org.springframework.remoting.support.RemoteInvocation;" +
                "!*");
        ObjectInputFilter.Config.setSerialFilter(filter);

        given()
            .port(port)
            .contentType("application/x-java-serialized-object")
            .body(this.getClass().getResourceAsStream("/exploit.ser")). // generated by ExploitExternal.main()
        when()
            .post(SERVICE_PATH).
        then()
            .statusCode(500);

        Thread.sleep(2000);

        assertThat(Files.exists(Paths.get("_HACKED_"))).isFalse();

        Files.deleteIfExists(Paths.get("_HACKED_"));
    }

    @Test
    @Order(4)
    void service_works(@LocalServerPort int port, @TempDir Path tempDir) throws Exception {
        RemoteInvocation ri = new RemoteInvocation(SERVICE_PATH, new Class[]{String.class}, new Object[]{"test"});
        serialize(ri, tempDir.resolve("request.ser"));

        given()
            .port(port)
            .contentType("application/x-java-serialized-object")
            .body(Files.newInputStream(tempDir.resolve("request.ser"))).
        when()
            .post(SERVICE_PATH).
        then()
            .statusCode(200);
    }

    private void createExploit(Path exploitFile, Path hackedFile) throws Exception {
        Vulnerable vulnerable = new Vulnerable();
        vulnerable.setObject(new Object());
        vulnerable.setProperty("myprop");

        Vulnerable exploited = new Exploit("mkdir " + hackedFile.toAbsolutePath())
                .exploited(vulnerable);

        serialize(vulnerable, exploitFile);
    }
}
